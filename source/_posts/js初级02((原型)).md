---
title: js初级02(原型)
date: 2013-10-04 22:14:37
tags: javascript 初级
---

#  关于\__ proto__的理解
每个对象那个在创建的的时候否会在其内部初始化一个\__ proto__属性,当访问一个对象的属性时,如果这个对象内部不存在这个属性,那么会去\__ proto\__里面去找,那么他就会去\__proto\__里找这个属性，这个\__proto\__又会有自己的\__proto\__，于是就这样一直找下去，也就是我们平时所说的原型链的概念。
 
# 动态创建
```
//创建一个构造函数
    function Student(age){
            this.age=age;
    }
    var stu=new Student(18);
    Student.prototype.say =function (){
        console.log("hahha");
    }
    console.log(stu);
```
- 通过Student创建出来的实例会指向Student.prototype,上述方法属于动态在创建(给构造函数.prototype添加了一个方法).给原型添加属性可以在创建实例之前也可以在创建实例之后,实例都可以访问原型中的方法.
- stu可以通难过stu.\__proto\__获取say.
- 也可以通过stu.say()
 
# 原型覆写
- 相比默认的原型对象construtor属性,会丢失
 
-  Student.prototype这种方式访问constructor属性不准确,因为会被覆写
手动修复在Student.prototype中添加属性"constructor:Student"(不写也没有是他并没有什么卵用)
- 注意:原型覆写注意代码顺序
 
- 原型覆写是尽量使用新对象
```
<script>
        var obj = {
            count: function (a, b) {
                console.log(a + b);
            },
            con: function (a) {
                console.log(a);
            }
        };
 
        // 注意事项3：覆写时尽量使用一个新对象
        function Student(age) {
            this.age = age;
        }
        // 覆写构造函数的prototype属性值
        // 把Student.prototype修改为一个新的自定义对象
        Student.prototype = obj;
        // 如果我想修改con方法，那么obj对象也会受到连带影响，因为赋值是地址,两个地址同时指向一个对象
        // 将来使用obj的时候，极有可能我已经忘记了这里对obj进行过修改，
        // 就可能出现问题，为了防止自己给自己挖坑，还是不要使用已存在的对象为好。
        console.log("--------------------");
        Student.prototype.con = function (a) {
            return a;
        };
       // var guoJing = new Student(38);
       // guoJing.run();
    </script>
```
## 实例与实例之间的继承
```
var o1={
        value:100
    }
    var o2={};
    o2.__proto__=o1;
    console.log(o2.value);
    console.log(o1);
    console.log(o2);
    //o1,o2均为实例,o2.__proto__指向o1
 
```
# 对象与对象之间的继承(混入)
```
<script>
    var o={val:100}
    var o2={}
    for(var key in o){
        o2[key]=o[key]
    }
    console.log(o2);
</script>
```
# 内置对象不可枚举
```
var obj={value:100};
obj.toString
obj.valueOf
for(var key in obj){
    console.log(key)//只能把我们自己的属性遍历出来了
}
```
# 另一种方法(混入原型中)
- 注意:在jQuery中也是这样用的
- 在jQuery中有个extend方法;
```
//    创建一个对象
    var obj={
        say:function (){
                console.log(this.name);
        }
    }
//    创建一个构造函数
    function Animal(name){
            this.name=name;
    }
    for(var key in obj){
        Animal.prototype[key]=obj[key];
    }
 
//    通过Animal创建实例
    var dog=new Animal("大黄");
    dog.say();
 
```
 
- extend函数封装
- 本质就是把多个对象的属性一次copy到原型对象中
 
```
function extend(o1,o2){
    for(var key in o2){
        o1[key]=o2[key]
    }
}
extend(dog.prototype,{
    val:100;
    name:"ll";
})
 
```
## copy继承的注意
1. 实现copy继承所需的函数名没有硬性要求
 
2. 乱用会造成内存浪费
 
3. 通常都是配合原型来使用(对原型进行扩展)
 
# Object.create
- Object是一个内置的构造函数
- 在Object身上有很多方法
 
```
//创建一个对象
    var o1 = {val: 100}
    //创建一个构造函数
    function Person(name) {
        this.name = name;
    }
    var per = new Person("ll")
    //指定per继承O1,即per.__proto__===obj
    //调用Object.create方法时会返回一个新对象这个新对象的地址赋值给per
    //并让per中的__proto__指向O1;
    per = Object.create(o1)
    console.log(per.val);
```
 
# Object.create加原型组合
 
```
     //创建两个构造函数
            function Animal(){
                    this.name=1;
            }
            function human(){
                    this.age=123;
            }
            human.prototype=new Animal();
            //创建实例
            var person=new human();
            console.log(person.name);
```
# 扩展1
```
// 需求：Person的实例可以使用Animal原型里面的方法
        function Animal(name, age, sex) {
            this.name = name;
            this.age = age;
            this.sex = sex;
        }
        Animal.prototype = {
            fn: function () {
                // 谁调用fn，this指向谁
                console.log(this.name);
            }
        };
        // 人类都是动物，动物不一定是人类，所以动物拥有的属性人类一定也有
        function Person(name, age, sex) {
            /*
            * 复用Animal构造函数里的代码解决思路：
            * 1、Animal里面有一些this.xx = xx的代码，
            * 2、如果，我能够让Animal里面的this指向Person的实例，
            * 3、那么Animal里面的代码含义就变成了给Person的实例添加xx属性。
            *
            * 那么问题来了，如何让Animal函数执行时，里面的this指向Person的实例：
            * 1、把Animal函数作为属性添加到Person实例自身，
            * 2、然后通过Person实例调用Animal函数，那么Animal执行时里面的this就指向了Person实例
            * */
            // 这种代码复用的方式：
            // 有地方叫它 对象冒充，也叫属性盗窃，也叫属性继承，
            // 最简单明了好理解的叫法是：构造函数借用
            // 借用Animal函数，给Person实例添加属性
            this.__Animal__ = Animal;
            // 调用Animal函数时，里的this指向了当前Person的实例
            this.__Animal__(name, age, sex);
        }
        // 这一行代码，为了让Person的实例能给使用Animal原型里面的东西
        Person.prototype = Object.create(Animal.prototype);
        var huangYaoShi = new Person('黄药师', 888, '男');
        console.log(huangYaoShi.age);
 
```
# 扩展2(extend)
```
/*
        * 需求：
        *
        * 给Fn构造函数添加一个extend函数，
        * 用来给构造函数添加静态成员。
        *
        * 给Fn的原型也添加一个extend函数，
        * 用来给将来的实例添加实例成员。
        * */
        function Fn() { }
        // 给Fn添加一个静态方法，供将来给Fn扩展其他静态成员
        Fn.extend = function (obj) {
            for ( var key in obj ) {
                this[key] = obj[key];
            }
        };
        // 给Fn添加静态成员
        Fn.extend({
            value: 100,
            max: 888
        });
        /*----------------------------------------------------------------------*/
        // 给Fn原型添加一个实例方法，供将来给Fn的原型扩展其他实例成员
        // 完成这个需求，添加到Fn的静态方法与添加到原型的实例方法一致，
        // 为了代码的复用，一般实例方法会利用静态方法实现。
        Fn.prototype.extend = Fn.extend;
        // 给Fn的原型添加实例成员
        Fn.prototype.extend({
            add: function () {},
            count: function () {}
        });
        console.log(Fn.value);
        console.log(Fn.prototype.count);
 
```
