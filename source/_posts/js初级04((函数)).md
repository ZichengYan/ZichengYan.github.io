---
title: js初级04(函数)
date: 2013-10-24 22:14:37
tags: javascript 初级
---

# 函数复习
 
### 函数返回值调用时不传参数
 
#### 函数调用没有return语句,会默认返回undefined
 
```
function f5() {}
console.log(f5()); //印f5调用后的返回值
 
```
#### 函数调用后返回一个基本数据类型
 
```
function f6() {
      return 2;
}
console.log(f6()); // 打印f6调用后的返回值
 
```
#### 函数调用返回一个对象
```
function f7() {
    return {};
}
console.log(f7()); // 打印f7调用后的返回值
 
```
#### 函数调用返回函数
```
function f8() {
      return function() {
      console.log('我被返回出去了');
   };
}
console.log(f8()); // 打印f8调用后的返回值
```
 
#### 函数调用返回另一函数的执行结果
```
    function f9() {
        return function() {
            console.log('我被返回出去了');
            return 2;
        }();
    }
    console.log(f9()); // 打印f9函数中的自调函数调用后的返回值
```
 
### 函数返回值调用时传入参数
 
#### f3函数功能：打印传入的第一个参数
 
```
    function f3() {
        console.log(arguments[0]);
    }
    // 调用f3函数，传入1
    f3(1);
    // 调用f3函数，传入1 + 1的运算结果
    f3(1 + 1);
 
```
##### 调用f3函数，传入的是f4变量(与上文有联系)
```
    // 会具象化这个变量的值，而f4是一个指针指向函数，
    // 具象化后传入的f4变成了指向函数的指针
    function f4() {}
    f3(f4);
```
```
    // 调用f3函数，传入的是f4的调用后的返回结果，
    // 因为f4没有return语句，所以f4调用后的返回结果为undefined，
    // 最终传入f3的参数变成了undefined
    f3(f4());
```
```
    // 调用f3函数，传入的是一个匿名函数
    f3(function() {
        console.log('传入f3的是一个匿名函数！');
    });
```
```
    // 调用f3函数，传入的是一个匿名函数调用后的返回结果
    f3(function() {
        return '传入f3的是自调函数的返回值！';
    }());
```
# 函数调用
 
 
```
function fn() {
            var obj = {};
            return obj;
}
console.log( fn() === fn() );  // false
 
//函数每调用一次都会新生成一个obj并且返回,所以false
```
 
 
 
```
   var obj = {};
        function f() {
            return obj;
        }
        console.log( f() === f() );  //  true
//对象在全局定义,函数调用只是去全局获取这个对象的地址(函数调用时obj没有被重新定义),所以每次的返回值都是相同的对象地址.
```
# 作用域链
 
#### 变量的所有有效区域(运行环境),统称为作用链
 
> 画出下面代码所有变量的影射图
 
```
    var a = 1;
    var b = 2;
    function add(par1, par2) {
        var c = 10;
        return function () {
            return par1 + par2 + c;
        }();
    }
    add(a, b);
 
```
 
# return基本数据类型和对象的区别
 
```
function fn() {
            var a = 1;
            return a;
        }
var a = fn();
var a2 = fn();
//fn执行结果是返回一个数值，那么a和a2分别存储返回数值的一个copy版本。
```
 
```
function fn() {
     var obj = {};
     return obj;
}
//fn执行结果是返回一个对象的地址，那么o和o2存储是同一个对象的地址。
var o = fn();
var o2 = fn();
```
 
# 闭包
 
> 以后面试问什么是闭包：可以访问非自身局部变量的函数就是闭包。函数内的函数就是闭包。
> 闭包的特点:利用闭包，可以在任何地方操作一个局部变量。
 
```
//如果想要阻止a的释放，必须要借助闭包
    function fn() {
        var a = 1;
        return function() {
            return a;
        };
    }
var f = fn();
var f2 = fn();
//f调用和f2调用后，得到的a值，是来源与同一个a的。
console.log(f());
console.log(f2());
 
```
#### 闭包应用环境
 
```
//如果想要阻止a的释放，必须要借助闭包
    function fn() {
        var a = 1;
        return function() {
            return a;
        };
    }
    var f = fn();
    var f2 = fn();
    //f调用和f2调用后，得到的a值，是来源与同一个a的。
    console.log(f());
    console.log(f2());
```
 
```
var cache = {};
    // 给缓存中添加数据
    function setCache(key, val) {
        cache[key] = val;
    }
    // 获取缓存中指定的数据
    function getCache(key) {
        return cache[key];
    }
    function getCacheObj() {
        var cache = {};
        // 给缓存中添加数据
        function setCache(key, val) {
            cache[key] = val;
        }
        // 获取缓存中指定的数据
        function getCache(key) {
            return cache[key];
        }
        return {
            setCache: setCache,
            getCache: getCache
        }
    }
    var cacheObj = getCacheObj();
    cacheObj.setCache('val', 888);
    console.log(cacheObj.getCache('val'));
 
```
# 执行环境
 
> 代码执行时所依赖的环境,函数被调用一次，就会产生一个执行环境。
 
#### 面试题
 
```
//问题:
var arr = ['第一句话','第二句话','第三句话','第四句话'];
        for ( var i = 0, len = arr.length; i < len; i++ ) {
            setTimeout(function () {
                console.log(arr[i]);
            }, 1000);
        }
 
//上面的代码要求，每隔一秒说一句话，找到存在的问题，并解决。
```
 
 
```
//上面题解决方法
//因为传入的定时器的回调,在循环结束之后才执行,所以打印的i值是4
var arr = ['第一句话','第二句话','第三句话','第四句话'];
        for ( var i = 0, len = arr.length; i < len; i++ ) {
            (function () {
                var par = i;
                setTimeout(function () {
                    console.log(arr[par]);
                }, 1000 * (par + 1));
            })();
        }
 
```
 
 
 
 
```
//另一种解决方法
//let 定义的变量具有块级作用域
var arr = ['第一句话','第二句话','第三句话','第四句话'];
       for ( let i = 0, len = arr.length; i < len; i++ ) {
           setTimeout(function () {
               console.log(arr[i]);
           }, 1000 * (i + 1));
       }
 
```
 
 
```
function setVal(val) {
    return function () {
        return val;
    }
}
 
/*var fn = setVal(566);
var val = fn();
console.log(val);*/
 
var arr = ['第一句话','第二句话','第三句话','第四句话'];
for ( var i = 0, len = arr.length; i < len; i++ ) {
    (function () {
        var fn = setVal(i);
        setTimeout(function () {
            console.log(arr[fn()]);
        }, 0);
    })();
}
 
 
```
 
#### 其他
```
 
function callback() {
    console.log(111);
}
// setTimeout是全局下的一个函数,
// 第一个参数要求是回调函数
// 传入setTimeout的回调函数，是异步执行的(即：不是随着代码的顺序执行)。
setTimeout(callback, 0);
console.log(222);
for ( var i = 0; i < 10; i++ ) {
    console.log(i);
}
 
```